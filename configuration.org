#+TITLE: Emacs configuration

* Defaults
** Add resources to load path
   #+BEGIN_SRC emacs-lisp
     (add-to-list 'load-path "~/.emacs.d/resources/")
   #+END_SRC

** Search init file for bugs
   #+BEGIN_SRC emacs-lisp
     (use-package bug-hunter)
   #+END_SRC

** Load =sensible-defaults.el= for some basic settings
   #+BEGIN_SRC emacs-lisp
     (load-file "~/.emacs.d/resources/sensible-defaults.el/sensible-defaults.el")
     (sensible-defaults/use-all-settings)
     (sensible-defaults/use-all-keybindings)
     (sensible-defaults/backup-to-temp-directory)
   #+END_SRC

** =use-package=
   Use =use-package= for fasters load and simplier dependency management

   #+BEGIN_SRC emacs-lisp
     (unless (package-installed-p 'use-package)
       (package-install 'use-package))
     (setq use-package-verbose t)
     (setq use-package-always-ensure t)

     (require 'use-package)
   #+END_SRC

   Always precompile and use the newest version.

   #+BEGIN_SRC emacs-lisp
     (use-package auto-compile
       :config (auto-compile-on-load-mode))
     (setq load-prefer-newer t)
   #+END_SRC

** Ignore uninterested files with =ignoramus.el=
   #+BEGIN_SRC emacs-lisp
     (load-file "~/.emacs.d/resources/ignoramus/ignoramus.el")
     (use-package ignoramus
       :ensure nil
       :config (ignoramus-setup))
   #+END_SRC

** =recentf=
   Disable recentf-cleanup on Emacs start, because it can cause problems with
   remote files

   #+BEGIN_SRC emacs-lisp
     (use-package recentf
       :config
       (setq recentf-save-file (expand-file-name "~/.emacs.d/private/cache/recentf")
             recentf-max-saved-items 500
             recentf-max-menu-items 15
             recentf-exclude (list "\\.git/.*\\'"
                                   "/elpa/.*\\'"
                                   "/itsalltext/")
             recentf-auto-cleanup 'never)
       (recentf-mode 1))
   #+END_SRC

** Force emacs to use its own internal password prompt
   #+BEGIN_SRC emacs-lisp
     (use-package pinentry
       :config
       (setq epa-pinentry-mode 'loopback)
       (pinentry-start))
   #+END_SRC

* Personal information
  #+BEGIN_SRC emacs-lisp
    (setq user-full-name "Valiantsin Mikhaliuk"
          user-mail-address "valiantsin.mikhaliuk@gmail.com"
          calendar-latitude 54.4
          calendar-longitude 18.65
          calendar-location-name "Gdansk, PL"
          calendar-week-start-day 1)
  #+END_SRC

 User interface preferences
** Automatically resize buffers using =golden-ratio= package
   #+BEGIN_SRC emacs-lisp
     (use-package golden-ratio
       :init
       (golden-ratio-mode t)
       (setq golden-ratio-auto-scale t))
   #+END_SRC

** Disable large file warning (> 100MB)
   #+BEGIN_SRC emacs-lisp
     (setq large-file-warning-threshold 100000000)
   #+END_SRC

** Which-key
   #+BEGIN_SRC emacs-lisp
     (use-package which-key
       :defer 10
       :config
       (progn
         (setq which-key-popup-type 'side-window)
         (setq which-key-compute-remaps t)
         (setq which-key-allow-multiple-replacements t))
       (which-key-mode))
   #+END_SRC

** Which-function
   #+BEGIN_SRC emacs-lisp
     (use-package which-func
       :ensure t
       :init)
   #+END_SRC

** Fonts
*** Set default font
    #+BEGIN_SRC emacs-lisp
      (setq nist/default-font "Dejavu Sans Mono")
      (setq nist/default-font-size 12)
      (setq nist/current-font-size nist/default-font-size)
      (setq default-frame-alist '((font . "Dejavu Sans Mono-12")))
    #+END_SRC

*** Handle resizing
    #+BEGIN_SRC emacs-lisp
      (setq nist/font-change-increment 1.1)

      (defun nist/set-font-size ()
        "Set the font to `nist/default-font` at `nist/current-font-size`."
        (set-frame-font
         (concat nist/default-font "-" (number-to-string nist/current-font-size))))

      (defun nist/reset-font-size ()
        "Change font size back to `nist/default-font-size'."
        (interactive)
        (setq nist/current-font-size nist/default-font-size)
        (nist/set-font-size))

      (defun nist/increase-font-size ()
        "Increase current font size by a factor of `nist/font-change-increment'."
        (interactive)
        (setq nist/current-font-size
              (ceiling (* nist/current-font-size nist/font-change-increment)))
        (nist/set-font-size))

      (defun nist/decrease-font-size ()
        "Decrease current font size by a factor of `nist/font-change-increment', down to a minimum size of 1."
        (interactive)
        (setq nist/current-font-size
              (max 1
                   (floor (/ nist/current-font-size nist/font-change-increment))))
        (nist/set-font-size))

      (define-key global-map (kbd "C-)") 'nist/reset-font-size)
      (define-key global-map (kbd "C-+") 'nist/increase-font-size)
      (define-key global-map (kbd "C-=") 'nist/increase-font-size)
      (define-key global-map (kbd "C-_") 'nist/decrease-font-size)
      (define-key global-map (kbd "C--") 'nist/decrease-font-size)

      (nist/reset-font-size)
    #+END_SRC

** Disable window chrome
   #+BEGIN_SRC emacs-lisp
     (tool-bar-mode 0)
     (menu-bar-mode 0)
     (scroll-bar-mode -1)
   #+END_SRC

** Use fancy lambdas
   Why not? ;)

   #+BEGIN_SRC emacs-lisp
     (global-prettify-symbols-mode +1)
   #+END_SRC

** Theme
   Setup transparency

   #+BEGIN_SRC emacs-lisp
     (defun nist/apply-transparency (value)
       "Sets the transparency of the frame window. 0=transparent/100=opaque."
       (interactive "nTransparency Value 0 - 100 opaque:")
       (set-frame-parameter (selected-frame) 'alpha value))
   #+END_SRC

   Install theme

   #+BEGIN_SRC emacs-lisp
     (use-package solarized-theme
       :defer t
       :config
       ;; (setq solarized-use-variable-pitch nil)
       ;; (setq solarized-height-plus-1 1.0)
       ;; (setq solarized-height-plus-2 1.0)
       ;; (setq solarized-height-plus-3 1.0)
       ;; (setq solarized-height-plus-4 1.0)
       (setq solarized-high-contrast-mode-line t)
       (if (daemonp)
           (add-hook 'after-make-frame-functions
                     (lambda (frame)
                       (with-selected-frame frame (nist/apply-solorized-dark-theme))))
         (nist/apply-solorized-dark-theme)))
   #+END_SRC

   Setup

   #+BEGIN_SRC emacs-lisp
     (defun nist/apply-solorized-dark-theme ()
       "Apply the `solorized-dark` theme"
       (interactive)
       (load-theme 'doom-nord-light t))
   #+END_SRC

   Apply theme

	 #+BEGIN_SRC emacs-lisp
     (if (daemonp)
         (add-hook 'after-make-frame-functions
       (lambda (frame)
         (with-selected-frame frame (nist/apply-solorized-dark-theme))))
       (nist/apply-solorized-dark-theme))
	 #+END_SRC

** Smooth scrolling
   #+BEGIN_SRC emacs-lisp
     (setq scroll-conservatively 100)
   #+END_SRC

** Disable cursor blinking
   #+BEGIN_SRC emacs-lisp
     (blink-cursor-mode -1)
   #+END_SRC

** Force utf-8 everywhere
   #+BEGIN_SRC emacs-lisp
     (set-charset-priority 'unicode)
     (setq locale-coding-system   'utf-8)   ; pretty
     (set-terminal-coding-system  'utf-8)   ; pretty
     (set-keyboard-coding-system  'utf-8)   ; pretty
     (set-selection-coding-system 'utf-8)   ; please
     (prefer-coding-system        'utf-8)   ; with sugar on top
     (setq default-process-coding-system '(utf-8-unix . utf-8-unix))
   #+END_SRC

** Highlight the current line
   =global-hl-line-mode= softly highlights the background color of the line
   containing point.

   #+BEGIN_SRC emacs-lisp
     (global-hl-line-mode)
   #+END_SRC

** Use =moody=
   #+BEGIN_SRC emacs-lisp
     (use-package moody
       :config
       (setq x-underline-at-descent-line t)
       (moody-replace-mode-line-buffer-identification)
       (moody-replace-vc-mode))
   #+END_SRC

** Use =minions= to diminish all minor modes
   #+BEGIN_SRC emacs-lisp
     (use-package minions
       :config (minions-mode 1))
   #+END_SRC

** Highlight uncommited changes using =diff-hl=
   #+BEGIN_SRC emacs-lisp
     (use-package diff-hl
       :ensure t
       :config
       (add-hook 'prog-mode-hook 'turn-on-diff-hl-mode)
       (add-hook 'vc-dir-mode-hook 'turn-on-diff-hl-mode))
   #+END_SRC

** Browser
*** Internal one
    #+BEGIN_SRC emacs-lisp
      (setq eww-download-directory "~/Downloads")
    #+END_SRC

*** External one
    #+BEGIN_SRC emacs-lisp
      (setq browse-url-browser-function 'browse-url-generic
            browse-url-generic-program "chromium")
    #+END_SRC

** Add stripes to a dired buffer
   #+BEGIN_SRC emacs-lisp
     (use-package stripe-buffer
       :ensure t
       :config
       (add-hook 'dired-mode-hook 'stripe-buffer-mode))
   #+END_SRC

** Configure =ivy= and =counsel=
   #+BEGIN_SRC emacs-lisp
     (use-package counsel
       :bind
       ("M-x" . 'counsel-M-x)
       ("C-s" . 'swiper)
       :config
       (use-package flx)
       (use-package smex)
       (ivy-mode 1)
       (setq ivy-use-virtual-buffers t)
       (setq ivy-count-format "(%d/%d) ")
       (setq ivy-initial-inputs-alist nil)
       (setq ivy-re-builders-alist
             '((swiper . ivy--regex-plus)
               (t . ivy--regex-fuzzy))))
   #+END_SRC

** =smartparens=
   #+BEGIN_SRC emacs-lisp
     (use-package evil-smartparens
       :ensure t
       :after evil
       :config
       (evil-smartparens-mode)
       (add-hook 'smartparens-enabled-hook #'evil-smartparens-mode))
   #+END_SRC

** Use =guru-mode= to escape ambiguous keystrokes
   #+BEGIN_SRC emacs-lisp
     (use-package guru-mode
       :ensure t
       :config
       (guru-global-mode 1)
       (add-hook 'prog-mode-hook 'guru-mode))
   #+END_SRC

* =evil-mode=
** Use =evil=
   #+BEGIN_SRC emacs-lisp
     (use-package evil
       :ensure t
       :init
       (progn
         (setq evil-want-C-u-scroll t
               evil-want-integration nil
               evil-want-abbrev-expand-on-insert-exit nil
               evil-want-keybinding nil)) ; needed by evil-collection
       :config
       (evil-mode 1))
   #+END_SRC

**  Enable =evil-surround= everywhere
   #+BEGIN_SRC emacs-lisp
     (use-package evil-surround
       :ensure t
       :after evil
       :config
       (global-evil-surround-mode 1))
   #+END_SRC

** =evil-collection=
   Adds evil bindings for a lot of modes
   #+BEGIN_SRC emacs-lisp
     (use-package evil-collection
     :ensure t
     :after evil
     :init
     (setq warning-suppress-types '((evil-collection))))
     #+END_SRC

* =dired=
** Extensions
   #+BEGIN_SRC emacs-lisp
     (use-package dired-details
       :ensure t)
   #+END_SRC

** Media
   #+BEGIN_SRC emacs-lisp
     (use-package dired-open
       :config
       (setq dired-open-extensions
             '(("mkv" . "mpv")
               ("mp4" . "mpv")
               ("avi" . "mpv"))))
   #+END_SRC

** Force dired to use =ls -lhvA=
   #+BEGIN_SRC emacs-lisp
     (setq-default dired-listing-switches "-lhvA")
   #+END_SRC

** Force dired to use =mv -r=
   #+BEGIN_SRC emacs-lisp
     (setq dired-recursive-copies 'always)
   #+END_SRC

   But ask before recursively deleteing an directory
   #+BEGIN_SRC emacs-lisp
     (setq dired-recursive-deletes 'top)
   #+END_SRC

** Kill buffer on file remove
   #+BEGIN_SRC emacs-lisp
     (setq dired-clean-up-buffers-too t)
   #+END_SRC

* Utility functions
** Add a list of patterns to associate files with modes

   #+BEGIN_SRC emacs-lisp
     (defun nist/add-auto-mode (mode &rest patterns)
       "Add entries to `auto-mode-alist' to use `MODE' for all given `PATTERNS'"
       (dolist (pattern patterns)
         (add-to-list 'auto-mode-alist (cons pattern mode))))
   #+END_SRC
** Open last file in dired buffer
   #+BEGIN_SRC emacs-lisp
     (defun nist/visit-last-dired-file ()
       "Open the last file in an open dired buffer."
       (end-of-buffer)
       (previous-line)
       (dired-find-file))
   #+END_SRC

** Visit last migration :ruby/rails:
   Relies on projectile

   #+BEGIN_SRC emacs-lisp
     (defun nist/visit-last-migration ()
       "Open the last file in 'db/migrate/'."
       (interactive)
       (dired (expand-file-name "db/migrate" (projectile-project-root)))
       (nist/visit-last-dired-file)
       (kill-buffer "migrate"))
   #+END_SRC

** Kill current buffer
   #+BEGIN_SRC emacs-lisp
     (defun nist/kill-current-buffer ()
       "Kill the current buffer silently."
       (interactive)
       (kill-buffer (current-buffer)))
   #+END_SRC

** Strip spaces (used for deft filenames)
   #+BEGIN_SRC emacs-lisp
     (defun nist/deft-strip-spaces (args)
       "Replace spaces with - in the string contained in the first element of the list args."
       (list (replace-regexp-in-string " " "-" (car args))))
   #+END_SRC

** Switch windows
   #+BEGIN_SRC emacs-lisp
     (defun nist/split-window-below-and-switch ()
       "Split the window horizontally, then switch to the new pane."
       (interactive)
       (split-window-below)
       (other-window 1))

     (defun nist/split-window-right-and-switch ()
       "Split the window vertically, then switch to the new pane."
       (interactive)
       (split-window-right)
       (other-window 1))
   #+END_SRC

** Transform brackets
   #+BEGIN_SRC emacs-lisp
     (defun transform-square-brackets-to-round-ones(string-to-transform)
       "Transforms [ into ( and ] into )"
       (concat
        (mapcar #'(lambda (c) (if (equal c ?[) ?\( (if (equal c ?]) ?\) c))) string-to-transform)))
   #+END_SRC

** Capture code snippets
   #+BEGIN_SRC emacs-lisp
     (defun nist/org-capture-get-src-block-string (major-mode)
       "Given a major mode symbol, return the associated org-src block
     string that will enable syntax highlighting for that language

     E.g. tuareg-mode will return 'ocaml', python-mode 'python', etc..."

       (let ((mm (intern (replace-regexp-in-string "-mode" "" (format "%s" major-mode)))))
         (or (car (rassoc mm org-src-lang-modes)) (format "%s" mm))))

     (defun nist/org-capture-code-snippet (f)
       (with-current-buffer (find-buffer-visiting f)
         (let ((code-snippet (buffer-substring-no-properties (mark) (- (point) 1)))
               (func-name (which-function))
               (file-name (buffer-file-name))
               (line-number (line-number-at-pos (region-beginning)))
               (org-src-mode (nist/org-capture-get-src-block-string major-mode)
               ))
           (format
            "
       file:%s::%s
       In ~%s~:
       ,#+BEGIN_SRC %s
       %s
       ,#+END_SRC"
            file-name
            line-number
            func-name
            org-src-mode
            code-snippet))))
   #+END_SRC

** Org-directory
   #+BEGIN_SRC emacs-lisp
     (defun nist/org-directory-file (name)
       "Prepend name with path to the org-directory root"
       (concat org-directory name))
   #+END_SRC

** Archive entry                                                        :org:
     Please don't touch habits.

     #+BEGIN_SRC emacs-lisp
       (defun nist/archive-entry ()
         "Mark the state of an org-mode item as DONE and archive it."
         (interactive)
         (if (string-equal "CANCELED" (org-entry-get nil "TODO"))
             nil (org-todo 'done))
         (org-archive-subtree)
         (save-some-buffers "archive.org")
         (kill-buffer "archive.org")
         (delete-other-windows)
         (save-buffer))
     #+END_SRC

** Open index file                                                      :org:
   #+BEGIN_SRC emacs-lisp
     (defun nist/open-index-file ()
       "Open the master org TODO list."
       (interactive)
       (find-file org-index-file)
       (flycheck-mode -1)
       (end-of-buffer))
   #+END_SRC

** Capture TODO                                                         :org:
   #+BEGIN_SRC emacs-lisp
     (defun nist/org-capture-todo ()
       (interactive)
       (org-capture :keys "t"))
   #+END_SRC

** Popup agenda                                                         :org:
   #+BEGIN_SRC emacs-lisp
     (defun nist/pop-to-org-agenda-view (key &optional split)
       "Visit the org agenda KEY, in the current window or a SPLIT."
       (let ((current-prefix-arg nil))
         (org-agenda nil key))
       (when (not split)
         (delete-other-windows)))

     (defun nist/pop-to-org-agenda-default (&optional nosplit)
       "Pop to the default agenda in a split window unless NOSPLIT."
       (interactive "P")
       (nist/pop-to-org-agenda-view "d" (not nosplit)))
   #+END_SRC

** Open org file                                                        :org:
   #+begin_src emacs-lisp
   #+end_src

** Skip habits in agenda view
   #+BEGIN_SRC emacs-lisp
     (defun nist/org-skip-subtree-if-habit ()
       "Skip an agenda if it has a STYLE property equal to \"habit\"."
       (let ((subtree-end (save-excursion (org-end-of-subtree t))))
         (if (string= (org-entry-get nil "STYLE") "habit")
             subtree-end
           nil)))
   #+END_SRC

** Skip org subtree in agenda view with given pririty
   #+BEGIN_SRC emacs-lisp
     (defun nist/org-skip-subtree-if-priority (priority)
       "Skip an agenda subtree if it has a priority of PRIORITY.
     PRIORITY may be one of the characters ?A, ?B, or ?C."
       (let ((subtree-end (save-excursion (org-end-of-subtree t)))
             (pri-value (* 1000 (- org-lowest-priority priority)))
             (pri-current (org-get-priority (thing-at-point 'line t))))
         (if (= pri-value pri-current)
             subtree-end
           nil)))
   #+END_SRC

** Insert =# frozen_string_literal: true= on save                      :ruby:
   #+BEGIN_SRC emacs-lisp
     (defun nist/ruby-mode-insert-frozen-string-literal-true ()
       (when (eq major-mode 'ruby-mode)
         (save-excursion
           (widen)
           (goto-char (point-min))
           (unless (looking-at "^# frozen_string_literal: true")
             (insert "# frozen_string_literal: true\n\n")))))
   #+END_SRC

** Hide minibuffer in Helm session if we use the header line as input field.
   #+BEGIN_SRC emacs-lisp
     (defun spacemacs//helm-hide-minibuffer-maybe ()
       "Hide minibuffer in Helm session if we use the header line as input field."
       (when (with-helm-buffer helm-echo-input-in-header-line)
         (let ((ov (make-overlay (point-min) (point-max) nil nil t)))
           (overlay-put ov 'window (selected-window))
           (overlay-put ov 'face
                        (let ((bg-color (face-background 'default nil)))
                          `(:background ,bg-color :foreground ,bg-color)))
           (setq-local cursor-type nil))))
   #+END_SRC

** Eval expression at point in =calc=
   #+BEGIN_SRC emacs-lisp
     (defun nist/calc-eval ()
       "Calculate match expression on current line using calc-eval"
       (interactive)
       (setq cLine
             (buffer-substring-no-properties
              (line-beginning-position)
              (line-end-position)))
       (save-excursion
         (end-of-line)
         (open-line 1))
       (forward-line 1)
       (insert (calc-eval '("evalv($)" calc-internal-prec 18) 'num cLine)))
   #+END_SRC

* Programming
** Common
*** Default tab width
   #+BEGIN_SRC emacs-lisp
     (setq-default tab-width 2)
   #+END_SRC

*** CamelCase everywhere
	 #+BEGIN_SRC emacs-lisp
     (use-package subword
       :init (global-subword-mode))
	 #+END_SRC

*** Scroll compilation window to bottom automatically
	 #+BEGIN_SRC emacs-lisp
	   (setq compilation-scroll-output t)
	 #+END_SRC

*** =Magit= (Emacs mode for interactions with or even More)
		#+BEGIN_SRC emacs-lisp
      (use-package evil-magit)
      (use-package magit
        :bind ("C-x g" . magit-status)
        :config
        (use-package evil-magit)
        (setq magit-push-always-verify nil)
        (add-hook 'git-commit-mode-hook 'turn-on-flyspell)
        (add-hook 'with-editor-mode-hook 'evil-insert-state))
		#+END_SRC

*** =company= for auto-completion
    #+BEGIN_SRC emacs-lisp
      (use-package company
        :ensure t
        :defer t
        :init (global-company-mode)
        :bind ("C-<return>" . company-complete-selection)
        :config
        (progn
          (bind-key [remap completion-at-point] #'company-complete company-mode-map)
          (setq company-tooltip-align-annotations t
                company-show-numbers t)
          (push 'company-robe company-backends)
          (setq company-dabbrev-downcase nil)))
    #+END_SRC

    =company-quickhelp=
    #+BEGIN_SRC emacs-lisp
      (use-package company-quickhelp
        :init (company-quickhelp-mode t)
        :config (setq company-quickhelp-mode t))
    #+END_SRC

    # Tabnine integration
    # #+BEGIN_SRC emacs-lisp
    #   (use-package company-tabnine
    #     :after company
    #     :config
    #     (add-to-list 'company-backends #'company-tabnine))
    # #+END_SRC

*** =lsp-mode=
    #+BEGIN_SRC emacs-lisp
      (use-package lsp-mode
        :config
        (add-hook 'lsp-after-open-hook 'lsp-enable-imenu)
        (add-hook 'prog-mode-hook #'lsp)
        (setq lsp-auto-guess-root t))

      (use-package company-lsp
        :config
        (push 'company-lsp company-backends))
    #+END_SRC

** Projectile
   #+BEGIN_SRC emacs-lisp
     (defun nist/search-project-for-symbol-at-point ()
       "Use `projectile-ag' to search the current project for `symbol-at-point'."
       (interactive)
       (projectile-ag (projectile-symbol-at-point)))

     (use-package projectile
       :ensure t
       :init (projectile-global-mode)
       :bind-keymap ("C-c p" . projectile-command-map)
       :bind
       ("C-c C-v" . 'nist/search-project-for-symbol-at-point)
       :config
       (setq projectile-require-project-root nil)
       (setq projectile-completion-system 'ivy)
       (setq projectile-switch-project-action 'magit-status)
       (define-key evil-normal-state-map (kbd "C-p") 'projectile-find-file)
       (define-key evil-normal-state-map (kbd "C-M-p") 'projectile-switch-project))
   #+END_SRC

** Flycheck
   #+BEGIN_SRC emacs-lisp
     (use-package flycheck
       :ensure t
       :init (global-flycheck-mode))
   #+END_SRC

** CSS and SASS
**** Indent 2 spaces
	 #+BEGIN_SRC emacs-lisp
		 (add-hook 'css-mode-hook (lambda ()
																(setq css-indent-offset 2)))
		 (add-hook 'scss-mode-hook (lambda ()
																 (setq css-indent-offset 2)))

	 #+END_SRC

**** Use =rainbow-mode=
		 #+BEGIN_SRC emacs-lisp
			 (use-package rainbow-mode
				 :ensure t)
		 #+END_SRC

**** Use =css-mode=
	 #+BEGIN_SRC emacs-lisp
		 (use-package css-mode
			 :config
			 (rainbow-mode))
	 #+END_SRC

**** Do not trigger compile on each save
		 #+BEGIN_SRC emacs-lisp
			 (use-package scss-mode
				 :config
				 (setq scss-compile-at-save nil))
		 #+END_SRC

** Haskell

	 Enable =haskell-doc-mode= (smart function signatures and smart indentation).

	 #+BEGIN_SRC emacs-lisp
     (setq exec-path (append exec-path (list "~/.cabal/bin")))
     (use-package haskell-mode
       :ensure t
       :config
       (add-hook 'haskell-mode-hook
                 (lambda ()
                   (haskell-doc-mode)
                   (turn-on-haskell-indent)
                   )))
	 #+End_SRC

** JavaScript
*** Coffee
	 #+BEGIN_SRC emacs-lisp
		 (use-package coffee-mode
			 :ensure t
			 :init
			 (setq js-indent-level 2)
			 (add-hook 'coffee-mode-hook
								 (lambda ()
									 (yas-minor-mode 1)
									 (setq coffee-tab-width 2)
									 (setq whitespace-action '(auto-cleanup)))))
	 #+END_SRC

	 After compiling coffee into js, I wan't to move to corresponding point in js file

	 #+BEGIN_SRC emacs-lisp
		 (setq coffee-args-compile '("-c" "--no-header" "-m"))
		 (add-hook 'coffee-after-compile-hook 'sourcemap-goto-corresponding-point)
	 #+END_SRC

	 Remove file after this dance

	 #+BEGIN_SRC emacs-lisp
		 (defun nist/coffee-after-compile-hook (props)
			 (sourcemap-goto-corresponding-point props)
			 (delete-file (plist-get props :sourcemap)))
		 (add-hook 'coffee-after-compile-hook 'nist/coffee-after-compile-hook)
	 #+END_SRC

*** VueJS
    #+BEGIN_SRC emacs-lisp
      (use-package vue-mode)
    #+END_SRC

** Lisps

	 Install required packages

	 #+BEGIN_SRC emacs-lisp
     (use-package paredit
       :ensure t)
     (use-package rainbow-delimiters
       :ensure t
       :init)
	 #+END_SRC

	 Add some hooks

	 #+BEGIN_SRC emacs-lisp
		 (setq lispy-mode-hooks
					 '(emacs-lisp-mode-hook
						 lisp-mode-hook
						 scheme-mode-hook))
		 (dolist (hook lispy-mode-hooks)
			 (add-hook hook (lambda ()
												(setq show-paren-style 'expression)
												(paredit-mode)
												(rainbow-delimiters-mode))))
	 #+END_SRC

	 Also use =eldoc-mode= in elisp buffers

	 #+BEGIN_SRC emacs-lisp
		 (add-hook 'emacs-lisp-mode-hook 'eldoc-mode)
	 #+END_SRC
** Python
	 More - [[https://github.com/howardabrams/dot-files/blob/master/emacs-python.org][in this tutorial]]

	 Indent 2 spaces.
	 #+BEGIN_SRC emacs-lisp
	   (setq python-indent 2)
	 #+END_SRC

	 Virtualenv

	 #+BEGIN_SRC emacs-lisp
		 (use-package pyenv-mode
			 :ensure t
			 :config
			 (defun projectile-pyenv-mode-set ()
				 "Set pyenv version matching project name."
				 (let ((project (projectile-project-name)))
					 (if (member project (pyenv-mode-versions))
							 (pyenv-mode-set project)
						 (pyenv-mode-unset))))
			 (add-hook 'projectile-switch-project-hook 'projectile-pyenv-mode-set)
			 (add-hook 'python-mode-hook 'pyenv-mode))

		 (use-package pyenv-mode-auto
			 :ensure t)
	 #+END_SRC

	 WSGI files (be careful with tabs>)

	 #+BEGIN_SRC emacs-lisp
		 (use-package python
			 :mode ("\\.py\\'" . python-mode)
						 ("\\.wsgi$" . python-mode)
			 :interpreter ("python" . python-mode)
			 :init
			 (setq-default indent-tabs-mode nil)
			 :config
			 (setq python-indent-offset 4)
			 (add-hook 'python-mode-hook 'smartparens-mode))
	 #+END_SRC

   =jedi= with company-backend

   #+BEGIN_SRC emacs-lisp
     (use-package jedi
       :ensure t
       :init
       (add-to-list 'company-backends 'company-jedi)
       :config
       (use-package company-jedi
         :ensure t
         :init
         (add-hook 'python-mode-hook (lambda () (add-to-list 'company-backends 'company-jedi)))
         (setq company-jedi-python-bin "python")))
   #+END_SRC

	 And finally =elpy=

	 #+BEGIN_SRC emacs-lisp
		 (use-package elpy
			 :ensure t
			 :commands elpy-enable
			 :init (with-eval-after-load 'python (elpy-enable))

			 :config
			 (electric-indent-local-mode -1)
			 (delete 'elpy-module-highlight-indentation elpy-modules)
			 (delete 'elpy-module-flymake elpy-modules)

			 (defun ha/elpy-goto-definition ()
				 (interactive)
				 (condition-case err
						 (elpy-goto-definition)
					 ('error (xref-find-definitions (symbol-name (symbol-at-point))))))

			 :bind (:map elpy-mode-map ([remap elpy-goto-definition] .
																	ha/elpy-goto-definition)))
	 #+END_SRC
** Ruby
*** Disable the ruby-reek cheker.

    #+BEGIN_SRC emacs-lisp
     (setq-default flycheck-disabled-checkers '(ruby-reek))
    #+END_SRC

*** Switch between implementation and spec

    #+BEGIN_SRC emacs-lisp
      (eval-after-load 'evil-ex
        '(evil-ex-define-cmd "A[switch to test/model in new window]"
                             'projectile-find-implementation-or-test-other-window))
      (eval-after-load 'evil-ex
        '(evil-ex-define-cmd "a[switch to test/model in current window"
                             'projectile-toggle-between-implementation-and-test))

    #+END_SRC

*** Rubocop-autocorrect-current-file
    #+BEGIN_SRC emacs-lisp
      (eval-after-load 'evil-ex
        '(evil-ex-define-cmd "cop[rubocop-autocorrect-current-file]"
                             'rubocop-autocorrect-current-file))

    #+END_SRC

*** Visit last migration

    #+BEGIN_SRC emacs-lisp
      (eval-after-load 'evil-ex
        '(evil-ex-define-cmd "vlm[visit-last-migration]"
                             'nist/visit-last-migration))
    #+END_SRC

*** =chruby=
    I use =chruby= to switch between versions of Ruby. This sets a default version
    to use within Emacs (for things like =xmp= or =rspec=).

    #+BEGIN_SRC emacs-lisp
      (use-package chruby
        :config
        (chruby "2.6.5"))
    #+END_SRC

*** Eval into comments
    =rcodetools= provides =xmp=, which lets us evaluate a Ruby buffer and
    display the result in "magic" (=# =>=) comments.

    #+BEGIN_SRC emacs-lisp
      (use-package seeing-is-believing
        :config
        (add-hook 'ruby-mode-hook 'seeing-is-believing)
        :init
        (setq seeing-is-believing-prefix "C-c C-c"
              seeing-is-believing-timeout 5.0))
    #+END_SRC

*** Robe

    #+BEGIN_SRC emacs-lisp
      (use-package robe
        :ensure t
        :bind ("C-M-." . robe-jump)
        :init
        (add-hook 'ruby-mode-hook 'robe-mode))
    #+END_SRC

*** RSpec
    Scroll rspec buffer to first error.

    #+BEGIN_SRC emacs-lisp
      (use-package rspec-mode
        :commands rspec-install-snippets
        :hook (dired-mode . rspec-dired-mode)
        :config
        (with-eval-after-load 'yasnippet (rspec-install-snippets))
        (setq rspec-use-spring-when-possible nil)
        (setq rspec-use-bundler-when-possible t)
        (add-hook 'rspec-compilation-mode-hook
                  (lambda ()
                    (chruby-use-corresponding)
                    (make-local-variable 'compilation-scroll-output)
                    (setq compilation-scroll-output 'first-error)))
        :ensure t)
    #+END_SRC

*** Features (Cucumber)
    #+BEGIN_SRC emacs-lisp
      (use-package feature-mode
        :ensure t
        :after ruby-mode
        :bind ("C-c ." . feature-goto-step-definition)
        :config
        (add-to-list 'auto-mode-alist '("\.feature$" . feature-mode))
        (setq feature-default-language "fi")
        (setq feature-step-search-path "features/step_definitions/*_steps.rb"))
    #+END_SRC

*** Rubocop
    #+BEGIN_SRC emacs-lisp
      (use-package rubocop
        :hook (ruby-mode . rubocop-mode))
    #+END_SRC

*** Refactoring helpers
    #+BEGIN_SRC emacs-lisp
      (use-package ruby-refactor
        :hook (ruby-mode . ruby-refactor-mode-launch))
    #+END_SRC

*** =ruby-end=
    Automatically insert end keyword
    #+BEGIN_SRC emacs-lisp
      (use-package ruby-end)
    #+END_SRC

*** Override =%= to play nicely with ruby blocks
    #+BEGIN_SRC emacs-lisp
      (evil-define-motion evil-ruby-jump-item (count)
        :jump t
        :type inclusive
        (cond ((string-match ruby-block-beg-re (current-word))
               (ruby-end-of-block count))
              ((string-match ruby-block-end-re (current-word))
               (ruby-beginning-of-block count))
              (t
               (evil-jump-item count))))
    #+END_SRC

*** =yard-mode=

    #+BEGIN_SRC emacs-lisp
      (use-package yard-mode :ensure t)
    #+END_SRC

*** =inf-ruby-mode=

    #+begin_src emacs-lisp
      (defun inf-ruby-remote ()
        "Run an inferior Ruby process on a remote server."
        (interactive)
        (let ((default-directory (format "/docker:%s:/bin/bash" (substring (shell-command-to-string "docker ps | grep backend | awk '{print \$1}' | head -n 1") 0 -1))))
          (inf-ruby)))
    #+end_src

*** =ruby-mode=
    Fit all together

    #+BEGIN_SRC emacs-lisp
      (add-hook 'ruby-mode-hook
                (lambda ()
                  (chruby-use-corresponding)
                  (setq ruby-insert-encoding-magic-comment nil)
                  (yas-minor-mode)
                  (rspec-mode)
                  (yard-mode)
                  (flycheck-mode)
                  (flycheck-disable-checker 'ruby-rubylint)
                  (flymake-mode-off)
                  (evil-smartparens-mode)
                  (smartparens-strict-mode)
                  (inf-ruby-minor-mode)
                  (subword-mode)
                  (local-set-key "\r" 'newline-and-indent)
                  (setq rspec-command-options "--color --order random")
                  (define-key ruby-mode-map (kbd "C-c r a") 'rspec-verify)
                  (define-key ruby-mode-map (kbd "C-c r r") 'rspec-verify-matching)
                  (define-key evil-normal-state-local-map "%" 'evil-ruby-jump-item)
                  (define-key evil-motion-state-local-map "%" 'evil-ruby-jump-item)
                  (add-hook 'ruby-mode-hook 'ruby-refactor-mode-launch)))

      (eval-after-load 'evil-ex
        '(evil-ex-define-cmd "fs[insert frozen string literal comment]"
                             'nist/ruby-mode-insert-frozen-string-literal))
    #+END_SRC

    Associate with a following files
    #+BEGIN_SRC emacs-lisp
      (nist/add-auto-mode
        'ruby-mode
        "\\Gemfile$"
        "\\.rake$"
        "\\.ru$"
        "\\.cap$"
        "\\Capfile$"
        "\\.gemspec$"
        "\\Guardfile$"
        "\\Rakefile$"
        "\\Vagrantfile$"
        "\\Vagrantfile.local$")
    #+END_SRC
*** Highlight coverage using SimpleCov
    #+BEGIN_SRC emacs-lisp
      (use-package coverage
        :ensure t
        :config
        (eval-after-load 'evil-ex
          '(evil-ex-define-cmd "cov[coverage]"
                               'coverage-mode)))
    #+END_SRC
** Shell
   #+BEGIN_SRC emacs-lisp
     (add-hook 'sh-mode-hook
               (lambda ()
                 (setq sh-basic-offset 2
                       sh-indentation 2)))
   #+END_SRC
** Web stuff
   #+BEGIN_SRC emacs-lisp
     (use-package web-mode
       :config
       (setq web-mode-markup-indent-offset 2)
       (setq web-mode-code-indent-offset 2)
       (setq web-mode-css-indent-offset 2)
       (setq js-indent-level 2)
       (setq web-mode-enable-auto-pairing nil)
       (setq web-mode-enable-auto-expanding t)
       (setq web-mode-enable-css-colorization t)
       (setq web-mode-enable-auto-closing t)
       (rainbow-mode)
       (rspec-mode)
       (yas-minor-mode))
   #+END_SRC

*** Use =web-mode= with embedded files to.
   #+BEGIN_SRC emacs-lisp
     (nist/add-auto-mode 'web-mode
       "\\.erb$"
       "\\.html$"
       "\\.php$"
       "\\.tpl$"
       "\\.css$"
       "\\.scss$"
       "\\.xml$"
       "\\.rhtml$")
   #+END_SRC

*** Please be polite with smartparens
    #+BEGIN_SRC emacs-lisp
      (sp-with-modes '(web-mode)
        (sp-local-pair "%" "%"
                       :unless '(sp-in-string-p)
                       :post-handlers '(((lambda (&rest _ignored)
                                           (just-one-space)
                                           (save-excursion (insert " ")))
                                         "SPC" "=" "#")))
        (sp-local-tag "%" "<% "  " %>")
        (sp-local-tag "=" "<%= " " %>")
        (sp-local-tag "#" "<%# " " %>"))
    #+END_SRC

*** =web-beautify=
    #+BEGIN_SRC emacs-lisp
      (use-package web-beautify
        :commands (web-beautify-css
                   web-beautify-css-buffer
                   web-beautify-html
                   web-beautify-html-buffer
                   web-beautify-js
                   web-beautify-js-buffer))
    #+END_SRC

*** =emmet=
    #+BEGIN_SRC emacs-lisp
      (use-package emmet-mode
        :bind* (("C-)" . emmet-next-edit-point)
                ("C-(" . emmet-prev-edit-point))
        :commands (emmet-mode
                   emmet-next-edit-point
                   emmet-prev-edit-point)
        :init
        (setq emmet-indentation 2)
        (setq emmet-move-cursor-between-quotes t)
        :hook web-mode)
    #+END_SRC
*** Nginx
    #+BEGIN_SRC emacs-lisp
      (use-package nginx-mode
        :commands (nginx-mode))
    #+END_SRC
*** Caddy
    #+BEGIN_SRC emacs-lisp
      (use-package caddyfile-mode
        :mode (("Caddyfile\\'" . caddyfile-mode)
               ("caddy\\.conf\\'" . caddyfile-mode)))
    #+END_SRC

*** JSON
    #+BEGIN_SRC emacs-lisp
      (use-package json-mode
        :bind* (("{" . paredit-open-curly)
                ("}" . paredit-close-curly)))
    #+END_SRC

** YAML
   #+BEGIN_SRC emacs-lisp
     (use-package yaml-mode
       :ensure t)
   #+END_SRC
** =dumb-jump=
   #+BEGIN_SRC emacs-lisp
     (use-package dumb-jump
       :after evil
       :config
       (setq dumb-jump-selector 'ivy)
       (define-key evil-normal-state-map (kbd "M-.") 'dumb-jump-go)
       (define-key evil-normal-state-map (kbd "M-,") 'dumb-jump-back)
       :init
       (dumb-jump-mode)
       :ensure)
   #+END_SRC

** Clojure
   #+begin_src emacs-lisp
     (use-package clojure-mode
       :ensure t
       :init
       (defconst clojure--prettify-symbols-alist
         '(("fn"   . ?λ)
           ("__"   . ?⁈)))

       :config
       (define-clojure-indent
         (defroutes 'defun)
         (GET 2)
         (POST 2)
         (PUT 2)
         (DELETE 2)
         (HEAD 2)
         (ANY 2)
         (context 2))
       (add-hook 'clojure-mode-hook 'global-prettify-symbols-mode)
       :bind (("C-c d f" . cider-code)
              ("C-c d g" . cider-grimoire)
              ("C-c d w" . cider-grimoire-web)
              ("C-c d c" . clojure-cheatsheet)
              ("C-c d d" . dash-at-point)))

     (use-package color-identifiers-mode
       :ensure t
       :init
       (add-hook 'clojure-mode-hook 'color-identifiers-mode))

     (defun cider-send-and-evaluate-sexp ()
       "Sends the s-expression located before the point or the active
       region to the REPL and evaluates it. Then the Clojure buffer is
       activated as if nothing happened."
       (interactive)
       (if (not (region-active-p))
           (cider-insert-last-sexp-in-repl)
         (cider-insert-in-repl
          (buffer-substring (region-beginning) (region-end)) nil))
       (cider-switch-to-repl-buffer)
       (cider-repl-closing-return)
       (cider-switch-to-last-clojure-buffer)
       (message ""))

     (use-package cider
       :ensure t
       :commands (cider cider-connect cider-jack-in)

       :init
       (setq cider-auto-select-error-buffer t
             cider-repl-pop-to-buffer-on-connect nil
             cider-repl-use-clojure-font-lock t
             cider-repl-wrap-history t
             cider-repl-history-size 1000
             cider-show-error-buffer t
             nrepl-hide-special-buffers t
             ;; Stop error buffer from popping up while working in buffers other than the REPL:
             nrepl-popup-stacktraces nil)

       ;; (add-hook 'cider-mode-hook 'cider-turn-on-eldoc-mode)
       (add-hook 'cider-mode-hook 'company-mode)

       (add-hook 'cider-repl-mode-hook 'paredit-mode)
       (add-hook 'cider-repl-mode-hook 'superword-mode)
       (add-hook 'cider-repl-mode-hook 'company-mode)
       (add-hook 'cider-test-report-mode 'jcf-soft-wrap)

       :bind (:map cider-mode-map
              ("C-c C-v C-c" . cider-send-and-evaluate-sexp)
              ("C-c C-p"     . cider-eval-print-last-sexp))

       :config
       (use-package slamhound)
       (setq org-babel-clojure-backend 'cider))

     (defun ha/cider-append-comment ()
       (when (null (nth 8 (syntax-ppss)))
         (insert " ; ")))

     (advice-add 'cider-eval-print-last-sexp :before #'ha/cider-append-comment)

     (use-package flycheck-clojure
       :ensure t
       :init
       (add-hook 'after-init-hook 'global-flycheck-mode)
       :config
       (use-package flycheck
         :config
         (flycheck-clojure-setup)))

     (use-package flycheck-pos-tip
       :ensure t
       :config
       (use-package flycheck
         :config
         (setq flycheck-display-errors-function 'flycheck-pos-tip-error-messages)))

     (use-package clj-refactor
       :ensure t
       :init
       (add-hook 'clojure-mode-hook 'clj-refactor-mode)
       :config
       ;; Configure the Clojure Refactoring prefix:
       (cljr-add-keybindings-with-prefix "C-c .")
       :diminish clj-refactor-mode)
   #+end_src

** Rust
   #+BEGIN_SRC emacs-lisp
     (use-package rust-mode
       :hook ((rust-mode . (lambda ()
                             (lsp)
                             (lsp-ui-doc-mode)
                             (lsp-ui-sideline-mode)
                             (eldoc-mode)
                             (flycheck-mode)
                             (smart-dash-mode)
                             (company-mode))))

       :bind (:map rust-mode-map
                   ("C-c v t" . wh/rust-toggle-visibility)
                   ("C-c m t" . wh/rust-toggle-mutability)
                   ("C-c v s" . wh/rust-vec-as-slice))
       :config
       (setq rust-indent-method-chain t)

       (defun my-rust-mode-hook ()
         (set (make-local-variable 'company-backends)
              '((company-lsp company-files :with company-yasnippet)
                (company-dabbrev-code company-dabbrev))))
       (add-hook 'rust-mode-hook #'my-rust-mode-hook)

       ;; format rust buffers using rustfmt(if it is installed)
       (add-hook 'rust-mode-hook
                 (lambda ()
                   (add-hook 'before-save-hook
                             (lambda ()
                               (time-stamp)
                               (lsp-format-buffer)) nil t)))

       (defun wh/rust-toggle-mutability ()
         "Toggle the mutability of the variable at point."
         (interactive)
         (save-excursion
           (racer-find-definition)
           (back-to-indentation)
           (forward-char 4)
           (if (looking-at "mut ")
               (delete-char 4)
             (insert "mut "))))

       (defun wh/rust-toggle-visibility ()
         "Toggle the public visibility of the function at point."
         (interactive)
         (save-excursion
           ;; If we're already at the beginning of the function definition,
           ;; `beginning-of-defun' moves to the previous function, so move elsewhere.
           (end-of-line)

           (beginning-of-defun)
           (if (looking-at "pub ")
               (delete-char 4)
             (insert "pub "))))

       (defun wh/rust-vec-as-slice ()
         "Convert the vector expression at point to a slice.
     foo -> &foo[..]"
         (interactive)
         (insert "&")
         (forward-symbol 1)
         (insert "[..]")))

     ;; cargo-mode: execute cargo commands easily
     ;; https://github.com/kwrooijen/cargo.el
     (use-package cargo
       :after rust-mode
       :hook ((rust-mode . cargo-minor-mode)))
   #+END_SRC

** Golang
*** Set environment
    #+BEGIN_SRC emacs-lisp
      (setenv "GOPATH" "/home/val/code/gocode")
      (setenv "GO111MODULE" "on")
      (setenv "PATH" "$HOME/bin:/usr/local/bin:/usr/sbin:/usr/bin:/usr/bin/heroku:/sbin:$HOME/bin:$HOME/.bin:$HOME/.cask/bin:$PATH:$GOPATH/bin")
    #+END_SRC

*** A bunch of useful packages
    #+BEGIN_SRC emacs-lisp
      (use-package go-mode :ensure t)
      (use-package gotest :ensure t)
      (use-package lsp-mode
        :ensure t
        :commands (lsp lsp-deferred)
        :hook (go-mode . lsp-deferred))

      (use-package lsp-ui
        :ensure t
        :commands lsp-ui-mode
        :init)

      (use-package yasnippet
        :ensure t
        :commands yas-minor-mode
        :hook (go-mode . yas-minor-mode))

      (use-package protobuf-mode
        :hook (protobuf-mode . (lambda ()
                                 (setq imenu-generic-expression
                                       '((nil "^[[:space:]]*\\(message\\|service\\|enum\\)[[:space:]]+\\([[:alnum:]]+\\)" 2))))))
    #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (defun  my-go-mode-hook ()
       (add-hook 'before-save-hook 'lsp-format-buffer)
       (add-hook 'before-save-hook 'lsp-organize-imports)

       (setq compile-command "go run .")
       (setq compilation-read-command t)
       (electric-pair-mode 1)

       (setq compilation-window-height 14)
       (defun val/go-compile-hook ()
         (when (not (get-buffer-window "*compilation*"))
           (save-selected-window
             (save-excursion
               (let* ((w (split-window-vertically))
                      (h (window-height w)))
                 (select-window w)
                 (switch-to-buffer "*compilation*")
                 (shrink-window (- h compilation-window-height)))))))
       (add-hook 'compilation-mode-hook 'val/go-compile-hook)

       ;; Key bindings specific to go-mode
       (local-set-key (kbd "C-c C-t") 'go-test-current-file)
       (local-set-key (kbd "M-.") 'godef-jump)         ; Go to definition
       (local-set-key (kbd "M-,") 'pop-tag-mark)       ; Return from whence you came
       (local-set-key (kbd "C-c C-r") 'val/go-compile-hook)
       (local-set-key (kbd "C-c C-p") 'compile)        ; Invoke compiler
       (local-set-key (kbd "C-c C-P") 'recompile)      ; Redo most recent compile cmd
       (local-set-key (kbd "C-c C-\\") 'lsp-ui-sideline-apply-code-actions)
       (local-set-key (kbd "M-]") 'next-error)         ; Go to next error (or msg)
       (local-set-key (kbd "M-[") 'previous-error)     ; Go to previous error or msg

       (setq lsp-gopls-server-path "/home/val/go/bin/gopls")

       (setq lsp-ui-doc-enable nil
             lsp-ui-peek-enable t
             lsp-ui-sideline-enable t
             lsp-ui-imenu-enable t
             lsp-ui-flycheck-enable t))

     ;; Connect go-mode-hook with the function we just defined
     (add-hook 'go-mode-hook 'my-go-mode-hook)
   #+END_SRC

** Graphviz
   Graph visualization

   #+BEGIN_SRC emacs-lisp
     (use-package graphviz-dot-mode
       :ensure t
       :mode "dot")
   #+END_SRC
** systemd services
   #+BEGIN_SRC emacs-lisp
     (use-package systemd)
   #+END_SRC
** Docker
   #+BEGIN_SRC emacs-lisp
     (use-package docker
       :bind ("C-c d" . docker)
       :config
       (setq docker-images-default-sort-key ("Created" . t))
       (setq docker-containers-default-sort-key ("Status" . t)))
     (use-package dockerfile-mode)
     (use-package docker-compose-mode)
     (use-package docker-tramp)
   #+END_SRC
** Chef
*** Setup foodcritic
   #+BEGIN_SRC emacs-lisp
     (use-package flycheck
       :no-require t
       :config
       (flycheck-define-checker chef-foodcritic
         "A Chef cookbooks syntax checker using Foodcritic.
     See URL `http://acrmp.github.io/foodcritic/'."
         :command ("foodcritic" source)
         :error-patterns
         ((error line-start (message) ": " (file-name) ":" line line-end))
         :modes (ruby-mode)
         :predicate
         (lambda ()
           (let ((parent-dir (file-name-directory (buffer-file-name))))
             (or
              ;; Chef CookBook
              ;; http://docs.opscode.com/chef/knife.html#id38
              (locate-dominating-file parent-dir "recipes")
              ;; Knife Solo
              ;; http://matschaffer.github.io/knife-solo/#label-Init+command
              (locate-dominating-file parent-dir "cookbooks"))))
         :next-checkers ((warnings-only . ruby-rubocop))))
   #+END_SRC

** Kubernetes
   #+begin_src emacs-lisp
     (use-package k8s-mode
       :ensure t
       :hook (k8s-mode . yas-minor-mode)
       :bind
       ("C-\\" . 'base64-decode-region)
       ("C-|" . 'base64-encode-region)
       )
   #+end_src

* Editing preferences
** Delete trailing white-space's
   #+BEGIN_SRC emacs-lisp
     (add-hook 'before-save-hook 'delete-trailing-whitespace)
   #+END_SRC

** Always kill current buffer
   #+BEGIN_SRC emacs-lisp
     (global-set-key (kbd "C-x k") 'nist/kill-current-buffer)
   #+END_SRC

** Save my location within a file
   Using =save-place-mode= saves the location of point for every file I visit.
   If I close the file or close the editor, then later re-open it, point will be
   at last place I visited.

   #+BEGIN_SRC emacs-lisp
     (use-package saveplace
       :init (save-place-mode t))
   #+END_SRC

** Always indent with spaces
   Never use tabs. (except Go & Rust) ;D

   #+BEGIN_SRC emacs-lisp
     (setq-default indent-tabs-mode nil)
   #+END_SRC

** Yasnippet
   #+BEGIN_SRC emacs-lisp
     (use-package yasnippet
       :init (yas-global-mode)
       :config
       (setq yas-snippet-dirs '("~/.emacs.d/snippets/text-mode")))
   #+END_SRC

   Use doom-snippets
   #+begin_src emacs-lisp
     (use-package doom-snippets
       :load-path "/home/val/.emacs.d/snippets/doom-snippets"
       :after yasnippet)
   #+end_src

** Configure =abbrev-mode=
   My name and email is too hard to spell, so I like to keep some personal
   information as abbreviations.

   #+BEGIN_SRC emacs-lisp
     (define-abbrev-table 'global-abbrev-table
       '(("zname" "Valiantsin Mikhaliuk")
         ("zemail" "valiantsin.mikhaliuk@gmail.com")
         ("zgithub" "http://github.com/vmikhaliuk")))
     (setq-default abbrev-mode t)
   #+END_SRC

** Configure =ido=
*** Defaults
    #+BEGIN_SRC emacs-lisp
      (setq ido-enable-flex-matching t)
      (setq ido-everywhere t)
      (ido-mode 1)
      (setq ido-create-new-buffer 'always)
    #+END_SRC
*** Better and faster matching
    #+BEGIN_SRC emacs-lisp
      (use-package flx-ido
        :ensure t
        :after ido
        :init (flx-ido-mode 1)
        :config (setq ido-enable-flex-matching t))
    #+END_SRC
*** Vertical buffer
    #+BEGIN_SRC emacs-lisp
      (use-package ido-vertical-mode
        :ensure t
        :init (ido-vertical-mode 1)
        :config (setq ido-vertical-define-keys 'C-n-and-C-p-only))
    #+END_SRC

*** Use =smex= to handle =M-x= with =ido=
   #+BEGIN_SRC emacs-lisp
     (use-package smex
       :init (smex-initialize)
       :bind* (("M-x" . smex)
               ("M-X" . smex-major-mode-commands)))
   #+END_SRC

** Markdown
   Render markdown using pandoc

   #+BEGIN_SRC emacs-lisp
     (use-package markdown-mode
       :mode (("\\.md$" . gfm-mode))
       :config
       (setq markdown-command "pandoc --standalone --mathjax --from=markdown")
       (add-hook 'gfm-mode-hook 'flyspell-mode)
       (add-hook 'gfm-mode-hook (lambda () (local-set-key (kbd "M-n") 'org-capture-todo))))
   #+END_SRC

** =AutoFillMode=
   #+BEGIN_SRC emacs-lisp
     (add-hook 'text-mode-hook 'turn-on-auto-fill)
     (add-hook 'text-mode-hook '(lambda () (set-fill-column 80)))
     (add-hook 'gfm-mode-hook 'turn-on-auto-fill)
     (add-hook 'gfm-mode-hook '(lambda () (set-fill-column 80)))
     (add-hook 'org-mode-hook 'turn-on-auto-fill)
     (add-hook 'org-mode-hook '(lambda () (set-fill-column 80)))

     (global-set-key (kbd "C-c q") 'auto-fill-mode)
   #+END_SRC

** Allow to modify region case
   #+BEGIN_SRC emacs-lisp
     (put 'downcase-region 'disabled nil)
     (put 'upcase-region 'disabled nil)
   #+END_SRC

** Switch windows when splitting
   #+BEGIN_SRC emacs-lisp
     (global-set-key (kbd "C-x 2") 'nist/split-window-below-and-switch)
     (global-set-key (kbd "C-x 3") 'nist/split-window-right-and-switch)
   #+END_SRC

** Search whatever-wherever using =engine-mode=
   #+BEGIN_SRC emacs-lisp
     (use-package engine-mode
       :init (engine-mode t)
       :config
       (defengine duckduckgo
         "https://duckduckgo.com/?q=%s"
         :keybinding "d")
       (defengine github
         "https://github.com/search?ref=simplesearch&q=%s"
         :keybinding "g")
       (defengine stack-overflow
         "https://stackoverflow.com/search?q=%s"
         :keybinding "s")
       (defengine wikipedia
         "http://www.wikipedia.org/search-redirect.php?language=en&go=Go&search=%s")
       (defengine arch-wiki
         "https://wiki.archlinux.org/index.php?title=Special:Search&search=%s&go=Go"
         :keybinding "a")
       (defengine wolfram-alpha
         "http://www.wolframalpha.com/input/?i=%s"
         :keybinding "w")
       (defengine youtube
         "https://www.youtube.com/results?search_query=%s"
         :keybinding "y"))
   #+END_SRC

** Edit comments in org-mode
   #+BEGIN_SRC emacs-lisp
     (use-package poporg
       :bind ("C-c M-;" . poporg-dwim))
   #+END_SRC

** Advice =beginning-of-line= to point to the first non-whitespace character
   #+BEGIN_SRC emacs-lisp
     (defadvice move-beginning-of-line (around smarter-bol activate)
       ;; Move to requested line if needed.
       (let ((arg (or (ad-get-arg 0) 1)))
         (when (/= arg 1)
           (forward-line (1- arg))))
       ;; Move to indentation on first call, then to actual BOL on second.
       (let ((pos (point)))
         (back-to-indentation)
         (when (= pos (point))
           ad-do-it)))
   #+END_SRC

** Use =helm=
   #+BEGIN_SRC emacs-lisp
     (use-package helm
       :after helm-config
       :bind
       (("C-c h" . helm-command-prefix)
        ("M-y" . helm-show-kill-ring)
        ("M-p" . helm-do-grep-ag)
        :map helm-map
        ("<tab>" . helm-execute-persistent-action)
        ("C-z" . helm-select-action)
        )
       :config
       (global-unset-key (kbd "C-x c"))
       (setq helm-buffers-fuzzy-matching t
             helm-recentf-fuzzy-match t)
       (setq helm-autoresize-mode t)
       (setq helm-buffer-max-length 40)
       (setq helm-google-suggest-use-curl-p t)
       (setq helm-split-window-in-side-p t
             helm-move-to-line-cycle-in-source t
             helm-ff-search-library-in-sexp t
             helm-ff-file-name-history-use-recentf t
             helm-echo-input-in-header-line t)

       (setq helm-grep-ag-command
             "rg --color=always --smart-case --no-heading --line-number %s %s %s")
       (setq helm-autoresize-max-height 0
             helm-autoresize-min-height 30
             helm-autoresize-mode 1)
       (add-hook 'helm-minibuffer-set-up-hook 'spacemacs//helm-hide-minibuffer-maybe))
   #+END_SRC

** Natural text linting
*** Use [[https://github.com/textlint/textlint][textlint]] to lint natural text
   #+BEGIN_SRC emacs-lisp
     (flycheck-define-checker textlint
       "A linter for textlint."
       :command ("npx" "textlint"
                 "--config" "~/.emacs.d/.textlintrc"
                 "--format" "unix"
                 "--rule" "write-good"
                 "--rule" "no-start-duplicated-conjunction"
                 "--rule" "max-comma"
                 "--rule" "terminology"
                 "--rule" "period-in-list-item"
                 "--rule" "abbr-within-parentheses"
                 "--rule" "alex"
                 "--rule" "common-misspellings"
                 "--rule" "en-max-word-count"
                 "--rule" "diacritics"
                 "--rule" "stop-words"
                 "--plugin"
                 (eval
                  (if (derived-mode-p 'text-mode)
                      "latex"
                    "@textlint/text"))
                 source-inplace)
       :error-patterns
       ((warning line-start (file-name) ":" line ":" column ":"
                 (message (one-or-more not-newline)
                          (zero-or-more "\n" (any " ") (one-or-more not-newline)))
                 line-end))
       :modes (text-mode latex-mode org-mode markdown-mode))
     (add-to-list 'flycheck-checkers 'textlint)
   #+END_SRC
*** Use =powerthesaurus= to find synonyms
    #+BEGIN_SRC emacs-lisp
      (use-package powerthesaurus
        :bind ("C-x w" . powerthesaurus-lookup-word-dwim))
    #+END_SRC

* Custom keybindings
  #+BEGIN_SRC emacs-lisp
    (global-set-key (kbd "C-w") 'backward-kill-word)
    (global-set-key (kbd "C-x C-k") 'kill-region)
    (global-set-key (kbd "M-/") 'hippie-expand)
    (global-set-key (kbd "M-o") 'other-window)
    (global-set-key (kbd "M-#") 'sort-lines)
    (global-set-key (kbd "C-c v c") 'nist/calc-eval)
  #+END_SRC

* Terminal
** =multi-term=
  #+BEGIN_SRC emacs-lisp
    (use-package multi-term
      :defer t
      :config
      (setq multi-term-program "bash")
      (evil-set-initial-state 'term-mode 'emacs)
      (define-key term-raw-map (kbd "M-o") 'other-window)
      (goto-address-mode))
  #+END_SRC

** Use =pop-shell= to quick commands

  #+BEGIN_SRC emacs-lisp
    (use-package shell-pop
      :bind ("C-c s" . shell-pop)
      :config
      (setq shell-pop-shell-type
            (quote ("multi-term" "*multi-term*"
                    (lambda nil (ansi-term shell-pop-term-shell)))))
      (setq shell-pop-term-shell "/bin/zsh")
      (shell-pop--set-shell-type 'shell-pop-shell-type shell-pop-shell-type))
  #+END_SRC

** SSH
   #+BEGIN_SRC emacs-lisp
     (defun ssh-to-host (x)
       "Ask for host."
       (interactive "sHost:")
       (let* ((buffer-name (format "*SSH %s*" x))
              (buffer (get-buffer buffer-name)))
         (if buffer
             (switch-to-buffer buffer)
           (multi-term)
           (term-send-string
            (get-buffer-process (rename-buffer buffer-name))
            (format "ssh -i ~/.ssh/deploy valiantsin_mikhaliuk@%s\r" x)))))
     (global-set-key (kbd "M-s s") 'ssh-to-host)
   #+END_SRC
* Org-mode
** General settings
   #+BEGIN_SRC emacs-lisp
     (use-package org-mode
       :ensure org-plus-contrib
       :defer t
       :init
       (setq org-directory "~/Dropbox/org/")
       (setq org-index-file "~/Dropbox/org/index.org")
       (setq org-archive-location
             (concat "~/Dropbox/archive.org" "::* From %s"))
       (setq org-clock-persist t)
       (org-clock-persistence-insinuate))
   #+END_SRC

** Agenda
*** Feed agenda with following files
   #+BEGIN_SRC emacs-lisp
          (setq org-agenda-files (list org-index-file
                                       "~/Dropbox/org/shop.org"
                                       "~/Dropbox/org/fitness.org"
                                       "~/Dropbox/org/projects.org"
                                       "~/Dropbox/org/work.org"
                                       "~/Dropbox/org/ideas.org"))
   #+END_SRC

*** Start agenda in =normal= mode
    #+BEGIN_SRC emacs-lisp
      (eval-after-load 'org-agenda
        '(progn (evil-set-initial-state 'org-agenda-mode 'normal)))
    #+END_SRC

*** Leave agenda with =q=
    #+BEGIN_SRC emacs-lisp
      (evil-define-key 'normal org-agenda-mode-map
        "q" 'org-agenda-quit)
    #+END_SRC

*** Custom agenda view
    #+BEGIN_SRC emacs-lisp
      (setq org-agenda-custom-commands
            '(("d" "Daily agenda and all TODOs"
               ((tags "PRIORITY=\"A\""
                      ((org-agenda-skip-function '(org-agenda-skip-entry-if 'todo 'done))
                       (org-agenda-overriding-header "High-priority unfinished tasks:")))
                (agenda "" ((org-agenda-ndays 1)))
                (alltodo ""
                         ((org-agenda-skip-function '(or (nist/org-skip-subtree-if-habit)
                                                         (nist/org-skip-subtree-if-priority ?A)
                                                         (org-agenda-skip-if nil '(scheduled deadline))))
                          (org-agenda-overriding-header "ALL normal priority tasks:"))))
               ((org-agenda-compact-blocks t)))))
    #+END_SRC

*** =org-habit=
    #+BEGIN_SRC emacs-lisp
      (use-package org-habit
        :ensure nil
        :after org
        :config
        (setq org-habit-graph-column 50))
    #+END_SRC

*** Send reminders about current task
    #+BEGIN_SRC emacs-lisp
      (use-package secretaria
        :config
        (add-hook 'after-init-hook #'secretaria-unknown-time-always-remind-me))
    #+END_SRC

** Keybindings
   #+BEGIN_SRC emacs-lisp
     (global-set-key (kbd "C-c l") 'org-store-link)
     (global-set-key (kbd "C-c a") 'org-agenda)
     (global-set-key (kbd "C-c c") 'org-capture)
     (global-set-key (kbd "C-c i") 'nist/open-index-file)
     (global-set-key (kbd "M-n") 'nist/org-capture-todo)
     (global-set-key (kbd "C-c t a") (lambda () (interactive) (nist/pop-to-org-agenda-default t)))
     (define-key org-mode-map (kbd "C-c C-x C-s") 'nist/archive-entry)
   #+END_SRC

** Display preferences
*** =org-bullets=
    #+BEGIN_SRC emacs-lisp
      (use-package org-bullets
        :ensure t
        :commands (org-bullets-mode)
        :init (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1))))
    #+END_SRC

*** Syntax highlight for edited blocks
    #+BEGIN_SRC emacs-lisp
      (setq org-src-fontify-natively t)
    #+END_SRC

*** spaces = tab pls
    #+BEGIN_SRC emacs-lisp
      (setq org-src-tab-acts-natively t)
    #+END_SRC

*** Use current window for pop-ups
    #+BEGIN_SRC emacs-lisp
      (setq org-src-window-setup 'current-window)
    #+END_SRC
** Exporting
*** General
    #+BEGIN_SRC emacs-lisp
      (setq org-export-initial-scope 'subtree)
    #+END_SRC

    Fix curly quotes when exporting
    #+BEGIN_SRC emacs-lisp
      (setq org-export-with-smart-quotes t)
    #+END_SRC

    Remove contact info from HTML footers
    #+BEGIN_SRC emacs-lisp
      (setq org-html-postamble nil)
    #+END_SRC

*** Markdown
    #+BEGIN_SRC emacs-lisp
      (use-package ox-md
        :after org
        :ensure t
        :disabled t
        :config
        (setq org-md-headline-style 'atx))
    #+END_SRC

    =gfm=
    #+BEGIN_SRC emacs-lisp
      (use-package ox-gfm
        :ensure t)
    #+END_SRC

*** Presentations
    Old but gold
    #+BEGIN_SRC emacs-lisp
      (use-package ox-beamer
        :after org
        :ensure t
        :disabled t
        :defer t)
    #+END_SRC

    Bootstrap
    #+BEGIN_SRC emacs-lisp
      (use-package ox-twbs
        :ensure t)
    #+END_SRC

    Google styled slides
    #+BEGIN_SRC emacs-lisp
      (use-package ox-ioslide
        :ensure t)
    #+END_SRC

*** =babel= evaluating customization
    Asynchronous execution
    #+BEGIN_SRC emacs-lisp
      (use-package ob-async :ensure t)
    #+END_SRC

    Prety useful for course/book notes.
    Also add non-standard go loader

    #+BEGIN_SRC emacs-lisp
      (use-package ob-go
        :ensure t)

      (org-babel-do-load-languages
       'org-babel-load-languages
       '((emacs-lisp . t)
         (R . t)
         (ruby . t)
         (haskell . nil)
         (latex . t)
         (ledger . t)
         (ocaml . t)
         (shell . t)
         (sql . t)
         (sqlite . t)
         (go . t)
         (dot . t)
         (python . t)
         (gnuplot . t)))
    #+END_SRC

    Stop asking before evaluating
    #+BEGIN_SRC emacs-lisp
      (setq org-confirm-babel-evaluate nil)
    #+END_SRC

*** PDF
    #+BEGIN_SRC emacs-lisp
      (setq org-latex-pdf-process
            '("pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
              "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
              "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"))
    #+END_SRC

    Source code highlighting with =minted= package

    #+BEGIN_SRC emacs-lisp
      (add-to-list 'org-latex-packages-alist '("" "minted"))
      (setq org-latex-listings 'minted)
    #+END_SRC

*** TeX configuration
    I maintain a two files in LaTeX, but I often export through it org-mode documents.

    Parse file after load
    #+BEGIN_SRC emacs-lisp
      (setq TeX-parse-self t)
    #+END_SRC

    Force =pdflatex= for compiling.

    #+BEGIN_SRC emacs-lisp
      (setq TeX-PDF-mode t)
    #+END_SRC

*** HTML
    #+BEGIN_SRC emacs-lisp
      (use-package htmlize
        :commands (htmlize-buffer
                   htmlize-file
                   htmlize-many-files
                   htmlize-many-files-dired
                   htmlize-region))
    #+END_SRC

** Calendar holidays
   #+BEGIN_SRC emacs-lisp
     (setq calendar-holidays
           '((holiday-fixed 1 1   "New Year")
             (holiday-fixed 1 6   "Trzech Króli")
             (holiday-fixed 4 21  "Wielkanoc")
             (holiday-fixed 4 22  "Poniedziałek Wielkanocny")
             (holiday-fixed 5 1   "Swięto pracy")
             (holiday-fixed 5 3   "Swięto konstytucji")
             (holiday-fixed 6 9   "Zesłanie Ducha Świętego (Zielone Świątki)")
             (holiday-fixed 6 20  "Boże Ciało")
             (holiday-fixed 8 15  "Święto Wojska Polskiego")
             (holiday-fixed 11 1  "Wszystkich Świętych")
             (holiday-fixed 11 11 "Święto Niepodległości")
             (holiday-fixed 12 25 "Boże Narodzenie (pierwszy dzień)")
             (holiday-fixed 12 26 "Boże Narodzenie (drugi dzień)")))
   #+END_SRC

** Open html files in browser after export when o pressed
   #+BEGIN_SRC emacs-lisp
     (add-hook 'org-mode-hook
               '(lambda () (setq org-file-apps
                                 (append '(("\\.x?html?\\'" . "/usr/bin/chromium %s"))))))
   #+END_SRC

** Quickly explore my =notes= directory with =deft=
   #+BEGIN_SRC emacs-lisp
     (use-package deft
       :bind ("C-c n" . deft)
       :commands (deft)
       :config

       (setq deft-directory "~/Dropbox/org/notes"
             deft-extensions '("org")
             deft-default-extension "org"
             deft-text-mode 'org-mode
             deft-auto-save-interval 0
             deft-recursive t
             deft-use-filter-string-for-filename t
             deft-use-filename-as-title t)
       (evil-set-initial-state 'deft-mode 'emacs)
       (advice-add 'deft-new-file-named :filter-args #'nist/deft-strip-spaces))
   #+END_SRC
** Task and capture management
**** Settings
     Start in insert-state

     #+BEGIN_SRC emacs-lisp
       (add-hook 'org-capture-mode-hook 'evil-insert-state)
     #+END_SRC

     Setup default task sequence
     #+BEGIN_SRC emacs-lisp
       (setq org-todo-keywords
             '((sequence "TODO" "IN-PROGRESS" "WAITING" "|" "DONE" "CANCELED")))
     #+END_SRC

**** Capture templates
     #+BEGIN_SRC emacs-lisp
       (setq org-capture-templates
             '(("i" "Idea"
                entry
                (file (lambda () (nist/org-directory-file "ideas.org")))
                "* TODO %?\n")

               ("c" "Code snippet"
                entry
                (file (lambda () (nist/org-directory-file "snippets.org")))
                "* %?\n%(nist/org-capture-code-snippet \"%F\")")

               ("s" "Shop"
                entry
                (file+headline (lambda () (nist/org-directory-file "shop.org")) "Index")
                "* TODO %?\nSCHEDULED: %^T\n")

               ("w" "Work"
                entry
                (file+headline (lambda () (nist/org-directory-file "work.org")) "Tasks")
                "* TODO %?\nSCHEDULED: %^T")

               ("t" "Todo"
                entry
                (file+headline org-index-file "Tasks")
                "* TODO %?\nSCHEDULED: %^T")))
     #+END_SRC

**** Add a timestamp to archived items
     #+BEGIN_SRC emacs-lisp
       (setq org-log-done 'time)
     #+END_SRC


** Use =evil= with Org agendas
   #+BEGIN_SRC emacs-lisp
     (use-package evil-org
       :after org
       :config
       (add-hook 'org-mode-hook 'evil-org-mode)
       (add-hook 'evil-org-mode-hook
                 (lambda () (evil-org-set-key-theme)))
       :init
       (require 'evil-org-agenda)
       (evil-org-agenda-set-keys))
   #+END_SRC
** Timetracking
*** Yeasily select latest entries
   #+BEGIN_SRC emacs-lisp
     (use-package org-mru-clock
       :bind* (("C-c C-x i" . org-mru-clock-in)
               ("C-c C-x C-j" . org-mru-clock-select-recent-task)))
   #+END_SRC

* Extensions
** =restclient=
   Useful mode to test API endpoints. Drop-in replacement to the postman

   #+BEGIN_SRC emacs-lisp
     (use-package restclient
       :ensure t)
   #+END_SRC
** =pdf-tools=
   #+BEGIN_SRC emacs-lisp
     (use-package pdf-tools
       :pin manual
       :config
       (pdf-tools-install)
       (evil-collection-init)
       (setq-default pdf-view-display-size 'fit-width)
       (evil-set-initial-state 'pdf-view-mode 'normal)
       (setq pdf-annot-activate-created-annotations t))
   #+END_SRC
** =org-pdfview=
   #+BEGIN_SRC emacs-lisp
     (use-package org-pdfview
       :ensure t)
   #+END_SRC
** =interleave=
   #+BEGIN_SRC emacs-lisp
     (use-package interleave
       :ensure t)
   #+END_SRC

* Shortcuts
** Emacs config
   #+BEGIN_SRC emacs-lisp
     (defun nist/visit-emacs-config ()
       (interactive)
       (find-file "~/.emacs.d/configuration.org"))

     (global-set-key (kbd "C-c t e") 'nist/visit-emacs-config)
   #+END_SRC
